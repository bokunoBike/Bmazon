第一部分基础知识 
第1章为什么要关心Java82 
1.1Java怎么还在变4 
1.1.1Java在编程语言生态系统中的位置4 
1.1.2流处理6 
1.1.3用行为参数化把代码传递给方法7 
1.1.4并行与共享的可变数据7 
1.1.5Java需要演变8 
1.2Java中的函数8 
1.2.1方法和Lambda作为一等公民9 
1.2.2传递代码：一个例子11 
1.2.3从传递方法到Lambda12 
1.3流13 
1.4默认方法17 
1.5来自函数式编程的其他好思想18 
1.6小结19 
第2章通过行为参数化传递代码20 
2.1应对不断变化的需求21 
2.1.1初试牛刀：筛选绿苹果21 
2.1.2再展身手：把颜色作为参数21 
2.1.3第三次尝试：对你能想到的每个属性做筛选22 
2.2行为参数化23 
2.3对付啰嗦27 
2.3.1匿名类28 
2.3.2第五次尝试：使用匿名类28 
2.3.3第六次尝试：使用Lambda表达式30 
2.3.4第七次尝试：将List类型抽象化31 
2.4真实的例子31 
2.4.1用Comparator来排序31 
2.4.2用Runnable执行代码块32 
2.4.3GUI事件处理32 
2.5小结33 
第3章Lambda表达式34 
3.1Lambda管中窥豹35 
3.2在哪里以及如何使用Lambda37 
3.2.1函数式接口37 
3.2.2函数描述符39 
3.3把Lambda付诸实践：环绕执行模式41 
3.3.1第1步：记得行为参数化41 
3.3.2第2步：使用函数式接口来传递行为42 
3.3.3第3步：执行一个行为42 
3.3.4第4步：传递Lambda42 
3.4使用函数式接口43 
3.4.1Predicate44 
3.4.2Consumer44 
3.4.3Function45 
3.5类型检查、类型推断以及限制49 
3.5.1类型检查49 
3.5.2同样的Lambda，不同的函数式接口50 
3.5.3类型推断51 
3.5.4使用局部变量52 
3.6方法引用53 
3.6.1管中窥豹53 
3.6.2构造函数引用55 
3.7Lambda和方法引用实战57 
3.7.1第1步：传递代码58 
3.7.2第2步：使用匿名类58 
3.7.3第3步：使用Lambda表达式58 
3.7.4第4步：使用方法引用59 
3.8复合Lambda表达式的有用方法59 
3.8.1比较器复合60 
3.8.2谓词复合60 
3.8.3函数复合61 
3.9数学中的类似思想62 
3.9.1积分62 
3.9.2与Java8的Lambda联系起来63 
3.10小结64 
第二部分函数式数据处理 
第4章引入流68 
4.1流是什么68 
4.2流简介72 
4.3流与集合74 
4.3.1只能遍历一次75 
4.3.2外部迭代与内部迭代76 
4.4流操作78 
4.4.1中间操作78 
4.4.2终端操作79 
4.4.3使用流80 
4.5小结81 
第5章使用流82 
5.1筛选和切片83 
5.1.1用谓词筛选83 
5.1.2筛选各异的元素83 
5.1.3截短流84 
5.1.4跳过元素85 
5.2映射86 
5.2.1对流中每一个元素应用函数86 
5.2.2流的扁平化87 
5.3查找和匹配90 
5.3.1检查谓词是否至少匹配一个元素90 
5.3.2检查谓词是否匹配所有元素90 
5.3.3查找元素91 
5.3.4查找第一个元素92 
5.4归约92 
5.4.1元素求和93 
5.4.2最大值和最小值94 
5.5付诸实践97 
5.5.1领域：交易员和交易98 
5.5.2解答99 
5.6数值流101 
5.6.1原始类型流特化101 
5.6.2数值范围102 
5.6.3数值流应用：勾股数103 
5.7构建流105 
5.7.1由值创建流106 
5.7.2由数组创建流106 
5.7.3由文件生成流106 
5.7.4由函数生成流：创建无限流107 
5.8小结110 
第6章用流收集数据111 
6.1收集器简介112 
6.1.1收集器用作高级归约112 
6.1.2预定义收集器113 
6.2归约和汇总114 
6.2.1查找流中的最大值和最小值114 
6.2.2汇总115 
6.2.3连接字符串116 
6.2.4广义的归约汇总117 
6.3分组120 
6.3.1多级分组121 
6.3.2按子组收集数据122 
6.4分区126 
6.4.1分区的优势126 
6.4.2将数字按质数和非质数分区128 
6.5收集器接口129 
6.5.1理解Collector接口声明的方法130 
6.5.2全部融合到一起134 
6.6开发你自己的收集器以获得更好的性能135 
6.6.1仅用质数做除数136 
6.6.2比较收集器的性能139 
6.7小结140 
第7章并行数据处理与性能141 
7.1并行流141 
7.1.1将顺序流转换为并行流142 
7.1.2测量流性能144 
7.1.3正确使用并行流147 
7.1.4高效使用并行流148 
7.2分支／合并框架149 
7.2.1使用RecursiveTask149 
7.2.2使用分支／合并框架的最佳做法153 
7.2.3工作窃取154 
7.3Spliterator155 
7.3.1拆分过程155 
7.3.2实现你自己的Spliterator157 
7.4小结162 
第三部分高效Java8编程 
第8章重构、测试和调试164 
8.1为改善可读性和灵活性重构代码164 
8.1.1改善代码的可读性165 
8.1.2从匿名类到Lambda表达式的转换165 
8.1.3从Lambda表达式到方法引用的转换166 
8.1.4从命令式的数据处理切换到Stream167 
8.1.5增加代码的灵活性168 
8.2使用Lambda重构面向对象的设计模式170 
8.2.1策略模式171 
8.2.2模板方法172 
8.2.3观察者模式173 
8.2.4责任链模式175 
8.2.5工厂模式177 
8.3测试Lambda表达式178 
8.3.1测试可见Lambda函数的行为179 
8.3.2测试使用Lambda的方法的行为179 
8.3.3将复杂的Lambda表达式分到不同的方法180 
8.3.4高阶函数的测试180 
8.4调试181 
8.4.1查看栈跟踪181 
8.4.2使用日志调试183 
8.5小结184 
第9章默认方法185 
9.1不断演进的API187 
9.1.1初始版本的API188 
9.1.2第二版API188 
9.2概述默认方法190 
9.3默认方法的使用模式192 
9.3.1可选方法192 
9.3.2行为的多继承192 
9.4解决冲突的规则196 
9.4.1解决问题的三条规则196 
9.4.2选择提供了最具体实现的默认方法的接口197 
9.4.3冲突及如何显式地消除歧义198 
9.4.4菱形继承问题200 
9.5小结201 
第10章用Optional取代null202 
10.1如何为缺失的值建模203 
10.1.1采用防御式检查减少Null—PointerException203 
10.1.2null带来的种种问题204 
10.1.3其他语言中null的替代品205 
10.2Optional类入门206 
10.3应用Optional的几种模式207 
10.3.1创建Optional对象208 
10.3.2使用map从Optional对象中提取和转换值208 
10.3.3使用flatMap链接Optional对象209 
10.3.4默认行为及解引用Optional对象213 
10.3.5两个Optional对象的组合213 
10.3.6使用filter剔除特定的值214 
10.4使用Optional的实战示例216 
10.4.1用Optional封装可能为null的值216 
10.4.2异常与Optional的对比217 
10.4.3把所有内容整合起来218 
10.5小结219 
第11章CompletableFuture：组合式异步编程220 
11.1Future接口222 
11.1.1Future接口的局限性223 
11.1.2使用CompletableFuture构建异步应用223 
11.2实现异步API224 
11.2.1将同步方法转换为异步方法225 
11.2.2错误处理227 
11.3让你的代码免受阻塞之苦228 
11.3.1使用并行流对请求进行并行操作229 
11.3.2使用CompletableFuture发起异步请求230 
11.3.3寻找更好的方案232 
11.3.4使用定制的执行器233 
11.4对多个异步任务进行流水线操作234 
11.4.1实现折扣服务235 
11.4.2使用Discount服务236 
11.4.3构造同步和异步操作237 
11.4.4将两个Completable—Future对象整合起来，无论它们是否存在依赖239 
11.4.5对Future和Completable—Future的回顾241 
11.5响应CompletableFuture的completion事件242 
11.5.1对最佳价格查询器应用的优化243 
11.5.2付诸实践244 
11.6小结245 
第12章新的日期和时间API246 
12.1LocalDate、LocalTime、Instant、Duration以及Period247 
12.1.1使用LocalDate和LocalTime247 
12.1.2合并日期和时间248 
12.1.3机器的日期和时间格式249 
12.1.4定义Duration或Period249 
12.2操纵、解析和格式化日期251 
12.2.1使用TemporalAdjuster253 
12.2.2打印输出及解析日期时间对象255 
12.3处理不同的时区和历法256 
12.3.1利用和UTC／格林尼治时间的固定偏差计算时区257 
12.3.2使用别的日历系统258 
12.4小结259 
第四部分超越Java8 
第13章函数式的思考262 
13.1实现和维护系统262 
13.1.1共享的可变数据263 
13.1.2声明式编程264 
13.1.3为什么要采用函数式编程265 
13.2什么是函数式编程265 
13.2.1函数式Java编程266 
13.2.2引用透明性268 
13.2.3面向对象的编程和函数式编程的对比268 
13.2.4函数式编程实战269 
13.3递归和迭代271 
13.4小结274 
第14章函数式编程的技巧275 
14.1无处不在的函数275 
14.1.1高阶函数275 
14.1.2科里化277 
14.2持久化数据结构278 
14.2.1破坏式更新和函数式更新的比较279 
14.2.2另一个使用Tree的例子281 
14.2.3采用函数式的方法282 
14.3Stream的延迟计算283 
14.3.1自定义的Stream283 
14.3.2创建你自己的延迟列表286 
14.4模式匹配290 
14.4.1访问者设计模式291 
14.4.2用模式匹配力挽狂澜292 
14.5杂项295 
14.5.1缓存或记忆表295 
14.5.2“返回同样的对象”意味着什么296 
14.5.3结合器296 
14.6小结297 
第15章面向对象和函数式编程的混合：Java8和Scala的比较299 
15.1Scala简介300 
15.1.1你好，啤酒300 
15.1.2基础数据结构：List、Set、Map、Tuple、Stream以及Option302 
15.2函数306 
15.2.1Scala中的一等函数307 
15.2.2匿名函数和闭包307 
15.2.3科里化309 
15.3类和trait310 
15.3.1更加简洁的Scala类310 
15.3.2Scala的trait与Java8的接口对比311 
15.4小结312 
第16章结论以及Java的未来313 
16.1回顾Java8的语言特性313 
16.1.1行为参数化（Lambda以及方法引用）314 
16.1.2流314 
16.1.3CompletableFuture315 
16.1.4Optional315 
16.1.5默认方法316 
16.2Java的未来316 
16.2.1集合316 
16.2.2类型系统的改进317 
16.2.3模式匹配318 
16.2.4更加丰富的泛型形式319 
16.2.5对不变性的更深层支持321 
16.2.6值类型322 
16.3写在最后的话325 
附录A其他语言特性的更新326 
附录B类库的更新330 
附录C如何以并发方式在同一个流上 
执行多种操作338 
附录DLambda表达式和JVM字 
节码346                                 --此文字指  版本。